<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockfront historical</title>
    <link type="text/css" rel="stylesheet" href="{{url_for('static', filename='css/master.css')}}"/>
    <link type="text/css" rel="stylesheet" href="{{url_for('static', filename='css/index.css')}}"/>
</head>
<body>
    <nav>
        <div id="menu">
            <h1><a href="{{url_for('index')}}">Blockfront historical</a></h1>
            <ul id="topinfo">
                <li><strong>{{players_online}}</strong> players online</li>
                <li id="last_update" title="Stats are fetched every 10 minutes"></li>
                <li><a href="{{url_for('find_player')}}">Player Stats</a></li>
                <li><a href="{{url_for('find_match')}}">Match Stats</a></li>   
                <li><a href="https://github.com/seth-the-cat/py_bf_historical">Github</a></li>
            </ul>
            <script>
                // Normalize the timestamp returned by SQLite ("YYYY-MM-DD HH:MM:SS") to a proper ISO-8601 UTC string
                const rawLastUpdated = "{{last_updated}}";
                let lastUpdatedIso = rawLastUpdated;
                if (!rawLastUpdated.includes('T')) {
                    // Replace the space between date and time with 'T' and append 'Z' to force UTC parsing
                    lastUpdatedIso = rawLastUpdated.replace(' ', 'T') + 'Z';
                } else if (!rawLastUpdated.endsWith('Z') && !/\+|\-/.test(rawLastUpdated)) {
                    // If it has a 'T' but no timezone, append 'Z'
                    lastUpdatedIso = rawLastUpdated + 'Z';
                }

                // Try parsing; if parsing fails, build a UTC date from components
                let lastUpdated = new Date(lastUpdatedIso);
                if (isNaN(lastUpdated.getTime())) {
                    const parts = rawLastUpdated.match(/(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})/);
                    if (parts) {
                        lastUpdated = new Date(Date.UTC(+parts[1], parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6]));
                    } else {
                        // Fallback to now to avoid misleading negative values
                        console.warn('Could not parse last_updated:', rawLastUpdated);
                        lastUpdated = new Date();
                    }
                }

                function updateLastUpdated() {
                    const now = new Date();
                    const diffMs = now - lastUpdated;
                    const diffMins = Math.floor(diffMs / 60000);
                    const diffSecs = Math.floor((diffMs % 60000) / 1000);
                    let displayText = "Last updated ";
                    // Reload briefly after ~10 minutes, show warnings for older values
                    if (diffMins >= 10 && diffMins < 11) {
                        location.reload();
                    } else if (diffMins > 11) {
                        displayText += `${diffMins} minutes ago. ⚠️ Stats fetching likely down. Contact seththecat.`;
                    } else if (diffMins > 0) {
                        displayText += `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
                    } else {
                        displayText += `${diffSecs} second${diffSecs !== 1 ? 's' : ''} ago`;
                    }
                    document.getElementById("last_update").innerText = displayText;
                }
                setInterval(updateLastUpdated, 1000);
                updateLastUpdated();
            </script>
        </div>
    </nav>
    <main>
        <div id="myplot"></div>
        <script type="module">

        import * as Plot from "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm";

        const data = {{raw_data | safe}};

        const plot = Plot.plot({
            color: {legend: true},
            style: {
                backgroundColor: "#000000",
                color: "#ffffff",
                overflow: "visible"
            },
            x: {
                label: "Date",
                grid: true
            },
            y: {
                label: "Players Online",
                grid: true
            },
            // Remove the global 'tip: true' to avoid conflicts
            // tip: true, 
            marks: [
                // --- Your Existing Lines ---
                Plot.lineY(data, {x: "Date", y: "Players", stroke: () => "Players", marker: "circle"}),
                Plot.lineY(data, {x: "Date", y: "Dom", stroke: () => "Dom", marker: "circle"}),
                Plot.lineY(data, {x: "Date", y: "TDM", stroke: () => "TDM", marker: "circle"}),
                Plot.lineY(data, {x: "Date", y: "Inf", stroke: () => "Inf", marker: "circle"}),
                Plot.lineY(data, {x: "Date", y: "GG", stroke: () => "GG", marker: "circle"}),
                Plot.lineY(data, {x: "Date", y: "TTT", stroke: () => "TTT", marker: "circle"}),
                Plot.lineY(data, {x: "Date", y: "Boot", stroke: () => "Boot", marker: "circle"}),

                // --- NEW: Interaction Layer ---
                
                // 1. Vertical Guide Line (Follows mouse)
                Plot.ruleX(data, Plot.pointerX({
                    x: "Date", 
                    stroke: "white", 
                    strokeOpacity: 0.2
                })),

                // 2. The Tooltip (aggregates all columns)
                Plot.tip(data, Plot.pointerX({
                    x: "Date",
                    y: "Players", // Anchors the tooltip box to the 'Players' line height
                    fill: "black",      // Background color
                    stroke: "#feffff",  // Text color
                    strokeWidth: 1,     // Make text crisp
                    
                    // This function creates the text inside the tooltip
                    title: (d) => `Players online on ${d.Date}\n
        Total Players: ${d.Players}
        Domination: ${d.Dom}
        Team Death Match: ${d.TDM}
        Infected: ${d.Inf}
        Gun Game: ${d.GG}
        Terrorist in Tratior Town: ${d.TTT}
        Bootcamp: ${d.Boot}`
                }),
            )
            ]
        })

        const div = document.querySelector("#myplot");
        div.append(plot);

        </script>
    </main>
    </body>
</html>